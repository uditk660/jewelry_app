<div class="container">
  <!-- ================= HEADER ================= -->
  <div class="page-header">
    <div>
      <h1>Sales Order</h1>
      <p class="lead">
        Create a new sales order by adding items, assigning a customer,
        and reviewing totals before submission.
      </p>
    </div>
    <div class="action-group">
      <%= link_to "Back to Orders", orders_path, class: "btn" %>
    </div>
  </div>

  <div class="card">

    <%= form_tag orders_path, method: :post, id: 'order-form' do %>

      <!-- ================= ORDER ITEMS ================= -->
      <div class="section-title">Order Items</div>

      <table class="items-table">
        <thead>
          <tr>
            <th style="min-width:200px">Item</th>
            <th style="min-width:110px">HUID</th>
            <th style="min-width:90px">HSN</th>
            <th style="min-width:70px">Qty</th>
            <th style="min-width:90px">Gross (g)</th>
            <th style="min-width:90px">Net (g)</th>
            <th style="min-width:90px">Rate</th>
            <th style="min-width:100px">Making %</th>
            <th style="min-width:90px">Add.</th>
            <th style="min-width:120px;text-align:right">Line Total</th>
            <th></th>
          </tr>
        </thead>

        <tbody id="order-items">
        </tbody>
      </table>

      <button type="button" id="add-order-row" class="btn">+ Add Item</button>

      <!-- ================= CUSTOMER + SUMMARY ================= -->
      <div class="customer-and-summary">

        <!-- CUSTOMER -->
        <div>
          <div class="section-title">Customer</div>

          <label>Existing Customer</label>
          <div style="display:flex; align-items:center; gap:12px;">
            <%= select_tag :existing_customer_id,
              options_from_collection_for_select(@customers, :id, :full_name),
              include_blank: "— Select customer —", id: 'existing_customer_id' %>

            <label style="font-weight:normal; margin:0;">
              <input type="checkbox" id="toggle-new-customer" style="margin-right:6px; vertical-align:middle;" /> Add new customer
            </label>
          </div>

          <div class="new-customer-card" id="new-customer-form" style="display:none">
            <%= fields_for :customer do |c| %>

              <div class="form-row">
                <div style="flex:1">
                  <label>Full Name</label>
                  <%= c.text_field :full_name, placeholder: 'John Doe' %>
                </div>
              </div>

              <label style="margin-top:8px">Address</label>
              <%= c.text_area :address, rows: 2 %>

              <div class="form-row" style="margin-top:8px">
                <div style="flex:1">
                  <label>Aadhaar / PAN</label>
                  <%= c.text_field :aadhaar_or_pan %>
                </div>
                <div style="flex:1">
                  <label>GST Number</label>
                  <%= c.text_field :gst_number %>
                </div>
              </div>

              <div class="form-row" style="margin-top:8px">
                <div style="flex:1">
                  <label>Email</label>
                  <%= c.email_field :email %>
                </div>
                <div style="flex:1">
                  <label>Phone</label>
                  <%= c.telephone_field :phone, maxlength: 10, inputmode: 'numeric', pattern: "\\d{10}", placeholder: '10 digits' %>
                </div>
              </div>

            <% end %>
          </div>
        </div>

        <!-- SUMMARY -->
        <div class="order-summary">
          <div class="summary-row"><div>Subtotal</div><div id="subtotal">₹0.00</div></div>
          <div class="summary-row muted"><div>Discount</div><div id="discount-display">₹0.00</div></div>
          <div class="summary-row muted"><div>Charges</div><div id="charges-display">₹0.00</div></div>

          <div class="summary-divider"></div>

          <div class="summary-row"><div>Taxable</div><div id="taxable">₹0.00</div></div>
          <div class="summary-row"><div>CGST</div><div id="cgst">₹0.00</div></div>
          <div class="summary-row"><div>IGST</div><div id="igst">₹0.00</div></div>

          <div class="summary-divider"></div>

          <div class="summary-row total">
            <div><strong>Total</strong></div>
            <div><strong id="grand-total">₹0.00</strong></div>
          </div>

          <!-- hidden inputs so the existing JS can read values and the server receives them -->
          <%= number_field_tag :discount, nil, step: 0.01, id: 'discount', style: 'display:none' %>
          <%= number_field_tag :charges, nil, step: 0.01, id: 'charges', style: 'display:none' %>
          <%= number_field_tag :cgst_rate, nil, step: 0.01, id: 'cgst_rate', style: 'display:none' %>
          <%= number_field_tag :igst_rate, nil, step: 0.01, id: 'igst_rate', style: 'display:none' %>
        </div>
      </div>

      <!-- ================= ACTIONS ================= -->
      <div class="footer-actions">
        <%= submit_tag "Create Order", class: "btn btn-primary", id: 'submit-order-bottom', disabled: true %>
      </div>

    <% end %>
  </div>
</div>

<style>
  /* hide native number input steppers (Chrome/Safari/Edge and Firefox) */
  input[type=number]::-webkit-outer-spin-button,
  input[type=number]::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  input[type=number] {
    -moz-appearance: textfield;
  }
</style>

<script>(function(){

  // items prepared server-side (controller provides @items = JewelryItem.available_for_sale)
  // include sku so we can show HUID in each row
  // include hsn so client can populate HSN input, plus weight_grams and effective per-gram price for totals
  const items = <%= raw((@items || []).map { |i|
        {
          id: i.id,
          name: i.name,
          quantity: i.quantity,
          sku: i.sku,
          hsn: (i.respond_to?(:hsn) ? i.hsn : nil),
          weight_grams: i.weight_grams,
          price: i.price,
          effective_price_per_gram: i.effective_price_per_gram,
          purity_total_weight: (i.purity ? i.purity.total_weight.to_f : nil)
        }
      }.to_json) %> || [];
  let tbody = null; // set after DOMContentLoaded to avoid early lookup
  // debug trace
  try{ console.log('orders/new script loaded, items count=', (items && items.length) || 0); }catch(e){}

  function money(v){ return '\u20B9' + v.toFixed(2); }

  // --- new helpers: prevent duplicate selections and keep selects in sync ---
  function getSelectedIds(){
  const ids = new Set();
  // defensive: if tbody not ready, return empty set
  if(!tbody) return ids;
  // look for hidden id inputs first (new text-box mode), fall back to selects
  tbody.querySelectorAll('input.item-id-hidden').forEach(i => { if(i && i.value) ids.add(String(i.value)); });
  tbody.querySelectorAll('.item-select').forEach(s => { if(s && s.value) ids.add(String(s.value)); });
  return ids;
  }

  function refreshAllItemSelects(){
  // update each select to remove/disable options that are already selected in other rows
  const selected = getSelectedIds();
  document.querySelectorAll('select.item-select').forEach(s => {
    const current = s.value;
    // rebuild options from available items + current selection
    const opts = items.map(it => {
      const disabled = selected.has(String(it.id)) && String(it.id) !== String(current);
      const weightLabel = (it.weight_grams || it.weight_grams === 0) ? ` (${it.weight_grams}g)` : '';
      const display = (it.name || '') + weightLabel;
      return `<option value="${it.id}"${String(it.id)===String(current) ? ' selected' : ''}${disabled? ' disabled' : ''}>${display}</option>`;
    }).join('');
    s.innerHTML = opts;
  });
  const availableCount = items.filter(it => !selected.has(String(it.id))).length;
  const addBtn = document.getElementById('add-order-row');
  // if there are zero known items, still allow adding a placeholder row so the user can enter data
  if(addBtn) addBtn.disabled = (items.length > 0 && availableCount === 0);
  }
  
  // call after DOM-mutations that change selected items

  function chooseDefaultForNewRow(){
    const selected = getSelectedIds();
    const avail = items.find(it => !selected.has(String(it.id)));
    return avail ? String(avail.id) : null;
  }

  // --- end helpers ---

  function addRow(){
    // choose a default available item to avoid duplicates
    const defaultId = chooseDefaultForNewRow();
  try{ console.log('addRow called, defaultId=', defaultId); }catch(e){}
    // if no default available item, still insert a placeholder row (with blank select) so one row is always visible
    const row = document.createElement('tr');
    // build a select with only available (not-selected) items
    const selected = getSelectedIds();
    const available = items.filter(it => !selected.has(String(it.id)));
    let optionsHtml = '';
    if(available.length > 0){
      optionsHtml = available.map(it => {
        const sel = String(it.id) === defaultId ? ' selected' : '';
        const weightLabel = (it.weight_grams || it.weight_grams === 0) ? ` (${it.weight_grams}g)` : '';
        const display = (it.name || '') + weightLabel;
        return `<option value="${it.id}"${sel}>${display}</option>`;
      }).join('');
    } else if(items.length > 0){
      // all items are selected in other rows; show a blank placeholder
      optionsHtml = '<option value="">— Select item —</option>';
    } else {
      // no known items at all; allow a blank select so user can still add a row
      optionsHtml = '<option value="">— Select item —</option>';
    }
    // pick an itemObj for populating HUID/rate/line total (may be empty)
    const itemObj = (defaultId ? items.find(it => String(it.id) === defaultId) : available[0]) || {};
    row.innerHTML = `
      <td>
        <select name="line_items[][jewelry_item_id]" class="item-select">${optionsHtml}</select>
      </td>
      <td><input type="text" name="line_items[][huid]" value="${itemObj.sku||''}" class="huid-field"></td>
      <td><input type="text" name="line_items[][hsn]" value=""></td>
      <td><input type="number" name="line_items[][quantity]" value="1" min="1" class="qty"></td>
      <td><input type="number" name="line_items[][gross_weight]" value="" step="0.01"></td>
      <td><input type="number" name="line_items[][net_weight]" value="${itemObj.weight_grams || ''}" step="0.01" class="net-weight"></td>
      <td><input type="number" name="line_items[][rate]" value="${(0).toFixed(2)}" class="rate-field"><span class="price-cell" style="display:none"></span></td>
      <td>
        <input type="number" name="line_items[][making_charge_percent]" value="0" step="0.01" class="making-percent">
        <input type="hidden" name="line_items[][making_charge]" value="0" class="making-rupee">
      </td>
      <td><input type="number" name="line_items[][additional_charge]" value="0" class="additional-charge"></td>
      <td class="line-total">${money(((itemObj.effective_price_per_gram || itemObj.price || 0) * (itemObj.weight_grams || 0) * 1) || 0)}</td>
      <td class="col-actions"><button type="button" class="btn remove">✕</button></td>
    `;
  tbody && tbody.appendChild(row);
  attachRowListeners(row);
  refreshAllItemSelects();
  updateRemoveButtons();
  recalc();
  try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){}
  }

  function attachRowListeners(row){
    const select = row.querySelector('.item-select');
    const hiddenId = row.querySelector('input.item-id-hidden');
    const qty = row.querySelector('.qty');
    const priceCell = row.querySelector('.price-cell');
    const lineTotal = row.querySelector('.line-total');
    // if we have a select, populate other fields when selection changes
    if(select){
      const populateFromId = function(idVal){
        const it = items.find(x => String(x.id) == String(idVal));
        const huidInput = row.querySelector('input[name="line_items[][huid]"]');
        const hsnInput = row.querySelector('input[name="line_items[][hsn]"]');
        const rateInput = row.querySelector('input[name="line_items[][rate]"]');
        const netInput = row.querySelector('input[name="line_items[][net_weight]"]') || row.querySelector('.net-weight');
          if(it){
          const perGram = parseFloat(it.effective_price_per_gram || it.price || 0);
          // always reflect the selected item's default net weight and recompute rate
          const netVal = parseFloat(it.weight_grams || 0) || 0;
          const q = parseInt(qty.value || 1) || 0;
          if(huidInput) huidInput.value = it.sku || '';
          if(hsnInput) hsnInput.value = it.hsn || '';
          if(netInput) netInput.value = netVal;
          // set max on net input according to purity availability when known
          if(netInput){
            if(it.purity_total_weight != null){
              netInput.setAttribute('max', String(it.purity_total_weight));
            } else {
              netInput.removeAttribute('max');
            }
          }
            if(rateInput && !rateInput.dataset.manual){ const cur = parseFloat(rateInput.value) || 0; if(cur === 0) rateInput.value = perGram.toFixed(2); }
          if(priceCell) priceCell.textContent = money(perGram) + ' /g';
          if(lineTotal) lineTotal.textContent = money(perGram * netVal * q);
        }
      };
      // initial populate
      if(select.value) populateFromId(select.value);
      select.addEventListener('change', function(){
        try{ console.log('select.change value=', select.value); }catch(e){}
        populateFromId(select.value);
        // after changing selection, other rows' selects need updating (to prevent duplicates)
        refreshAllItemSelects();
        recalc();
        updateSubmitButtons();
      });
    }

    // wire rate input to mark manual edits so auto-fill won't override them
    const rateInputRow = row.querySelector('input[name="line_items[][rate]"]') || row.querySelector('.rate-field') || row.querySelector('.rate');
    if(rateInputRow){
      rateInputRow.addEventListener('input', function(){
        try{ this.dataset.manual = '1'; }catch(e){}
        try{ recalc(); updateSubmitButtons(); }catch(e){}
      });
    }

    qty && qty.addEventListener('input', function(){
      const idVal = hiddenId ? hiddenId.value : (select ? select.value : null);
      const it = items.find(x => String(x.id) == String(idVal));
      const netInput = row.querySelector('input[name="line_items[][net_weight]"]') || row.querySelector('.net-weight');
      const net = parseFloat((netInput && netInput.value) || 0) || 0;
      const q = parseInt(qty.value || 0) || 0;
      const perGram = it ? parseFloat(it.effective_price_per_gram || it.price || 0) : 0;
      if(lineTotal && (perGram || q || net)) lineTotal.textContent = money(perGram * net * q);
      const rateInput = row.querySelector('input[name="line_items[][rate]"]'); if(rateInput && !rateInput.dataset.manual){ const cur = parseFloat(rateInput.value) || 0; if(cur === 0) rateInput.value = perGram.toFixed(2); }
      recalc();
      // validate quantity against available catalog quantity
      try{
        if(it && typeof it.quantity !== 'undefined'){
          const avail = parseInt(it.quantity || 0);
          if(q > avail){
            qty.classList.add('field-error');
            qty.title = `Max available: ${avail}`;
          } else {
            qty.classList.remove('field-error');
            qty.removeAttribute('title');
          }
        } else {
          qty.classList.remove('field-error');
          qty.removeAttribute('title');
        }
      }catch(e){}
      try{ if(typeof updateSubmitButtons === 'function') updateSubmitButtons(); }catch(e){}
      try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){}
    });
    const netEl = row.querySelector('input[name="line_items[][net_weight]"]');
    netEl && netEl.addEventListener('input', function(){
      const idVal = hiddenId ? hiddenId.value : (select ? select.value : null);
      const it = items.find(x => String(x.id) == String(idVal));
      const net = parseFloat(netEl.value || 0) || 0;
      const q = parseInt((row.querySelector('.qty')||{value:1}).value || 1) || 0;
      const perGram = it ? parseFloat(it.effective_price_per_gram || it.price || 0) : 0;
      if(lineTotal) lineTotal.textContent = money(perGram * net * q);
      const rateInput = row.querySelector('input[name="line_items[][rate]"]'); if(rateInput && !rateInput.dataset.manual){ const cur = parseFloat(rateInput.value) || 0; if(cur === 0) rateInput.value = perGram.toFixed(2); }
      recalc();
      // validate against purity availability (if provided)
      try{
        const mx = netEl.max ? parseFloat(netEl.max) : null;
        const selId = select ? String(select.value) : null;
        const cum = selId ? getCumulativeNetForItem(selId) : 0;
        const avail = (it && it.purity_total_weight != null) ? parseFloat(it.purity_total_weight) : null;
        if(avail != null){
          if(cum > avail){ netEl.classList.add('field-error'); }
          else { netEl.classList.remove('field-error'); }
          // update shared tooltip if visible
          updateNetTooltip(netEl);
        } else {
          if(mx && net > mx){ netEl.classList.add('field-error'); } else { netEl.classList.remove('field-error'); }
        }
      }catch(e){}
      try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){}
    });

    // tooltip handlers for NET input
    if(netEl){
      netEl.addEventListener('focus', function(){ showNetTooltip(netEl); updateNetTooltip(netEl); });
      netEl.addEventListener('blur', function(){ hideNetTooltip(); });
      netEl.addEventListener('input', function(){ updateNetTooltip(netEl); });
    }
    const rem = row.querySelector('.remove'); if(rem) rem.addEventListener('click', function(){
      // prevent deleting the only remaining row
      const rows = tbody ? tbody.querySelectorAll('tr') : [];
      if(rows.length <= 1){ alert('Cannot remove the only row.'); return; }
      row.remove(); refreshAllItemSelects(); updateRemoveButtons(); recalc(); updateSubmitButtons();
    });
  }

  // ensure existing server-side rows are synced
  refreshAllItemSelects();

  function updateRemoveButtons(){
    const rows = tbody.querySelectorAll('tr');
    const removes = tbody.querySelectorAll('button.remove');
    if(rows.length <= 1){
      removes.forEach(b => b.setAttribute('disabled', 'disabled'));
    } else {
      removes.forEach(b => b.removeAttribute('disabled'));
    }
  }

  // delay wiring that touches the DOM; support Turbolinks and regular loads
  function initOrderFormOnce(){
    // idempotent init but support Turbolinks cached-body restore
    try{
      if(window._orders_init_done){
        // page restored from cache — reacquire DOM nodes and re-bind lightweight handlers
        tbody = document.getElementById('order-items');
        const addBtnEl = document.getElementById('add-order-row');
        if(addBtnEl && !addBtnEl.dataset._orders_bound){ addBtnEl.addEventListener('click', addRow); addBtnEl.dataset._orders_bound = '1'; }
        if(tbody && !tbody.dataset._orders_input_bound){
          tbody.addEventListener('input', function(e){ recalc(); try{ if(typeof updateSubmitButtons === 'function') updateSubmitButtons(); }catch(e){} try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){} if(e && e.target){ if(e.target.name && e.target.name.match(/net_weight|quantity|making_charge|making_charge_percent|additional_charge/)) e.target.classList.remove('field-error'); } });
          tbody.dataset._orders_input_bound = '1';
        }
        // ensure at least one row exists so first item appears
        if(tbody && !tbody.querySelectorAll('tr').length) addRow();
        refreshAllItemSelects();
        updateRemoveButtons();
        try{ if(typeof updateSubmitButtons === 'function') updateSubmitButtons(); }catch(e){}
        try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){}
        return;
      }
    }catch(e){}

    tbody = document.getElementById('order-items');
    try{ console.log('initOrderFormOnce, tbody found=', !!tbody); }catch(e){}
    refreshAllItemSelects();
    updateRemoveButtons();
    // some apps may not define updateSubmitButtons; guard it
    try{ if(typeof updateSubmitButtons === 'function') updateSubmitButtons(); }catch(e){}
    try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){}
    const addBtnEl = document.getElementById('add-order-row');
    if(addBtnEl && !addBtnEl.dataset._orders_bound){ addBtnEl.addEventListener('click', addRow); addBtnEl.dataset._orders_bound = '1'; }
    // start with one row if none
    if(tbody && !tbody.querySelectorAll('tr').length) addRow();
    // wire tbody input listener (only after tbody exists)
    if(tbody && !tbody.dataset._orders_input_bound){
      tbody.addEventListener('input', function(e){ recalc(); try{ if(typeof updateSubmitButtons === 'function') updateSubmitButtons(); }catch(e){} try{ if(typeof updateAddButtonState === 'function') updateAddButtonState(); }catch(e){} if(e && e.target){ if(e.target.name && e.target.name.match(/net_weight|quantity|making_charge|making_charge_percent|additional_charge/)) e.target.classList.remove('field-error'); } });
      tbody.dataset._orders_input_bound = '1';
    }
    window._orders_init_done = true;
  }

  document.addEventListener('DOMContentLoaded', initOrderFormOnce);
  document.addEventListener('turbolinks:load', initOrderFormOnce);

  function recalc(){
    let subtotal = 0;
    const rows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
    rows.forEach(r => {
      const idInput = r.querySelector('input.item-id-hidden');
      const select = r.querySelector('.item-select');
      const idVal = idInput ? idInput.value : (select ? select.value : null);
      const qty = parseInt((r.querySelector('.qty')||{value:0}).value || 0) || 0;
      const netInput = r.querySelector('input[name^="line_items"][name$="[net_weight]"]') || r.querySelector('.net-weight');
      const rateInput = r.querySelector('input[name="line_items[][rate]"]') || r.querySelector('.rate-field') || r.querySelector('.rate');
      const net = parseFloat((netInput && netInput.value) || 0) || 0;
      const explicitRate = rateInput ? (parseFloat(rateInput.value) || 0) : 0;
      const isManualRate = rateInput ? String(rateInput.dataset.manual) === '1' : false;
      // read making as percent and compute rupee amount for submission
      const makingPercentEl = r.querySelector('input[name^="line_items"][name$="[making_charge_percent]"]');
      const makingPercent = parseFloat((makingPercentEl||{value:0}).value || 0) || 0;
      const it = items.find(x => String(x.id) == String(idVal));
      let lineAmount = 0;
      // read per-item additional charge (rupees)
      const addEl = r.querySelector('input[name^="line_items"][name$="[additional_charge]"]');
      const addPerItem = parseFloat((addEl||{value:0}).value || 0) || 0;
      if(it){
        const perGram = parseFloat(it.effective_price_per_gram || it.price || 0) || 0;
        const effectiveRate = (isManualRate || explicitRate > 0) ? explicitRate : perGram;
        const baseAmount = effectiveRate * net * qty;
        const making = baseAmount * (makingPercent/100.0);
        const makingHidden = r.querySelector('input[name^="line_items"][name$="[making_charge]"]');
        if(makingHidden) makingHidden.value = making.toFixed(2);
        const addTotal = addPerItem * qty;
        lineAmount = baseAmount + (isNaN(making) ? 0 : making) + addTotal;
        if(rateInput && !rateInput.dataset.manual){ const cur = parseFloat(rateInput.value) || 0; if(cur === 0) rateInput.value = perGram.toFixed(2); }
      } else {
        const making = 0;
        const makingHidden = r.querySelector('input[name^="line_items"][name$="[making_charge]"]');
        if(makingHidden) makingHidden.value = making.toFixed(2);
        const rateInput = r.querySelector('input[name="line_items[][rate]"]'); if(rateInput) rateInput.value = (0).toFixed(2);
      }
      const lineTotalEl = r.querySelector('.line-total');
      if(lineTotalEl) lineTotalEl.textContent = money(lineAmount);
      subtotal += lineAmount;
    });
    const discount = parseFloat((document.getElementById('discount')||{value:0}).value || 0);
    const charges = parseFloat((document.getElementById('charges')||{value:0}).value || 0);
    const taxable = subtotal - discount + charges;
    const cgstRate = parseFloat((document.getElementById('cgst_rate')||{value:0}).value || 0);
    const igstRate = parseFloat((document.getElementById('igst_rate')||{value:0}).value || 0);
    const cgst = taxable * (cgstRate/100);
    const igst = taxable * (igstRate/100);
    const subtotalEl = document.getElementById('subtotal'); if(subtotalEl) subtotalEl.textContent = money(subtotal);
    const discountEl = document.getElementById('discount-display'); if(discountEl) discountEl.textContent = money(discount);
    const chargesEl = document.getElementById('charges-display'); if(chargesEl) chargesEl.textContent = money(charges);
    const taxableEl = document.getElementById('taxable'); if(taxableEl) taxableEl.textContent = money(taxable);
    const cgstEl = document.getElementById('cgst'); if(cgstEl) cgstEl.textContent = money(cgst);
    const igstEl = document.getElementById('igst'); if(igstEl) igstEl.textContent = money(igst);
    const grandEl = document.getElementById('grand-total'); if(grandEl) grandEl.textContent = money(taxable + cgst + igst);
  }

  ['discount','charges','cgst_rate','igst_rate'].forEach(id => { const el = document.getElementById(id); if(el) el.addEventListener('input', function(){ recalc(); updateSubmitButtons(); }); });

  // ensure remove buttons state after initial row (will be run on DOMContentLoaded)

  // client-side validation: require customer (existing or new) and at least one item
  function showFormError(msg){
    clearFormError();
    const err = document.createElement('div');
    err.id = 'form-error';
    err.style.color = 'red';
    err.style.margin = '8px 0';
    err.textContent = msg || 'Please correct the form errors.';
    const form = document.getElementById('order-form');
    if(form && form.parentNode) form.parentNode.insertBefore(err, form);
  }

  // quick, non-UI validation used to toggle the disabled state of Create buttons
  function isFormValidQuiet(){
    // customer presence
    const existingEl = document.getElementById('existing_customer_id');
    const existing = existingEl ? existingEl.value : '';
    const toggle = document.getElementById('toggle-new-customer');
    if(!existing && (!toggle || !toggle.checked)) return false;
    if(toggle && toggle.checked){
      const fullEl = document.querySelector('input[name="customer[full_name]"]');
      const addrEl = document.querySelector('textarea[name="customer[address]"]');
      const phoneEl = document.querySelector('input[name="customer[phone]"]');
      const full = fullEl ? fullEl.value.trim() : '';
      const addr = addrEl ? addrEl.value.trim() : '';
      const phone = phoneEl ? (phoneEl.value || '').replace(/\D/g,'') : '';
      if(!full || !addr || !phone) return false;
      if(phone.length !== 10) return false;
    }
    // items validity: at least one row with selected item, qty>0, net_weight>0
    const rows = tbody ? tbody.querySelectorAll('tr') : [];
    if(rows.length === 0) return false;
    for(const r of rows){
      const qty = parseInt((r.querySelector('.qty')||{value:0}).value || 0);
  const idInput = r.querySelector('input.item-id-hidden');
  const sel = idInput ? idInput : r.querySelector('.item-select');
      const nweightEl = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
      const weight = nweightEl ? parseFloat(nweightEl.value || 0) : 0;
      if(!sel || !sel.value) return false;
      if(qty <= 0) return false;
      // ensure qty does not exceed available stock
      try{
        const idVal = sel.value;
        const it = items.find(x => String(x.id) == String(idVal));
        if(it && typeof it.quantity !== 'undefined'){
          if(qty > parseInt(it.quantity || 0)) return false;
        }
      }catch(e){}
      if(!weight || weight <= 0 || isNaN(weight)) return false;
    }
    return true;
  }

  function clearFormError(){
    const err = document.getElementById('form-error'); if(err) err.remove();
  }

  function validateForm(){
    clearFormError();
    const existingEl = document.getElementById('existing_customer_id');
    const existing = existingEl ? existingEl.value : '';
    const toggle = document.getElementById('toggle-new-customer');
    if(!existing && (!toggle || !toggle.checked)){
      showFormError('Please select an existing customer or add a new customer.');
      return false;
    }
    if(toggle && toggle.checked){
      const fullEl = document.querySelector('input[name="customer[full_name]"]');
      const addrEl = document.querySelector('textarea[name="customer[address]"]');
      const phoneEl = document.querySelector('input[name="customer[phone]"]');
      const full = fullEl ? fullEl.value.trim() : '';
      const addr = addrEl ? addrEl.value.trim() : '';
      const phone = phoneEl ? phoneEl.value.trim() : '';
      if(!full || !addr || !phone){
        showFormError('Please fill Full Name, Address and Phone for the new customer.');
        return false;
      }
      if((phone || '').replace(/\D/g,'').length !== 10){
        showFormError('Phone must be 10 digits.');
        return false;
      }
    }
    // ensure at least one item and qty > 0
    const rows = tbody ? tbody.querySelectorAll('tr') : [];
    if(rows.length === 0){ showFormError('Please add at least one item to the order.'); return false; }
    for(const r of rows){
      const qty = parseInt((r.querySelector('.qty')||{value:0}).value || 0);
      const idInput = r.querySelector('input.item-id-hidden');
      const sel = idInput ? idInput : r.querySelector('.item-select');
      const nweightEl = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
      const weight = nweightEl ? parseFloat(nweightEl.value || 0) : 0;
      if(!sel || !sel.value){ showFormError('Please choose an item for each row.'); return false; }
      if(qty <= 0){ showFormError('Quantity must be at least 1 for each item.'); return false; }
      if(!weight || weight <= 0 || isNaN(weight)){ showFormError('Net weight must be provided and greater than 0 for each item.'); return false; }
    }
    return true;
  }

  // validate on form submit
  const orderForm = document.getElementById('order-form');
  if(orderForm) orderForm.addEventListener('submit', function(e){
    if(!validateForm()){ e.preventDefault(); return false; }
    clearFormError();
  });

  // modal helpers (defensive)
  function showModalErrors(messages){
    const list = document.getElementById('error-modal-list'); if(!list) return;
    list.innerHTML = '';
    messages.forEach(m => { const li = document.createElement('li'); li.textContent = m; list.appendChild(li); });
    const modal = document.getElementById('error-modal'); if(modal) modal.style.display = 'flex';
  }
  function closeModal(){ const modal = document.getElementById('error-modal'); if(modal) modal.style.display = 'none'; }
  const emClose = document.getElementById('error-modal-close'); if(emClose) emClose.addEventListener('click', function(){ closeModal(); focusFirstInvalid(); });
  const emOk = document.getElementById('error-modal-ok'); if(emOk) emOk.addEventListener('click', function(){ closeModal(); focusFirstInvalid(); });

  function focusFirstInvalid(){
    const first = document.querySelector('.field-error');
    if(first){ first.focus(); first.scrollIntoView({behavior:'smooth', block:'center'}); }
  }

  // highlight fields when showing errors
  function highlightFieldsForErrors(){
    // clear previous
    document.querySelectorAll('.field-error').forEach(el => el.classList.remove('field-error'));
    const rows = tbody ? tbody.querySelectorAll('tr') : [];
    for(const r of rows){
      const w = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
      if(w && (w.value === '' || parseFloat(w.value) <= 0 || isNaN(parseFloat(w.value)))){
        w.classList.add('field-error');
      }
    }
    // customer fields
    const toggle = document.getElementById('toggle-new-customer');
    const existingSel = document.getElementById('existing_customer_id');
    if((!existingSel || !existingSel.value) && (!toggle || !toggle.checked)){
      // no customer selected
      if(existingSel) existingSel.classList.add('field-error');
    }
    if(toggle && toggle.checked){
      ['customer[first_name]','customer[phone]'].forEach(n => {
        const el = document.querySelector(`[name="${n}"]`);
        if(el && !el.value.trim()) el.classList.add('field-error');
      });
      // validate phone length
      const phoneEl = document.querySelector('input[name="customer[phone]"]');
      if(phoneEl){ const digits = (phoneEl.value||'').replace(/\D/g,''); if(digits.length !== 10) phoneEl.classList.add('field-error'); }
    }
  }

  // if server sent errors, show modal and highlight
  if(window.serverErrors && window.serverErrors.length){
    showModalErrors(window.serverErrors);
    highlightFieldsForErrors();
  }

  // update client-side validateForm to highlight fields on error
  const originalValidate = validateForm;
  validateForm = function(){
    const ok = originalValidate();
    if(!ok){ highlightFieldsForErrors(); }
    return ok;
  };

  // toggles for customer form (defensive)
  const toggleEl = document.getElementById('toggle-new-customer');
  const newCust = document.getElementById('new-customer-form');
  const existingSelect = document.getElementById('existing_customer_id');
  if(toggleEl){
    toggleEl.addEventListener('change', function(){
      if(toggleEl.checked){
        if(newCust) newCust.style.display = 'block';
        if(existingSelect){ existingSelect.value = ''; existingSelect.disabled = true; }
      } else {
        if(newCust) newCust.style.display = 'none';
        if(existingSelect) existingSelect.disabled = false;
      }
    });
  }
  if(existingSelect){
    existingSelect.addEventListener('change', function(){
      if(existingSelect.value){
        if(toggleEl) toggleEl.checked = false;
        if(newCust) newCust.style.display = 'none';
        existingSelect.disabled = false;
      }
    });
  }

  // wire top submit button to the form (defensive)
  const topSubmit = document.getElementById('submit-order-top');
  if(topSubmit){ topSubmit.addEventListener('click', function(e){ e.preventDefault(); const of = document.getElementById('order-form'); if(of) of.submit(); }); }

  // enable/disable Create buttons based on customer presence
  function hasValidCustomer(){
    const existingEl = document.getElementById('existing_customer_id');
    const toggleEl2 = document.getElementById('toggle-new-customer');
    if(existingEl && existingEl.value) return true;
    if(toggleEl2 && toggleEl2.checked){
      const f = document.querySelector('input[name="customer[full_name]"]');
      const p = document.querySelector('input[name="customer[phone]"]');
      const pv = p ? (p.value || '').replace(/\D/g,'') : '';
      return f && p && f.value.trim() !== '' && pv.length === 10;
    }
    return false;
  }

  function updateSubmitButtons(){
    const ok = isFormValidQuiet();
    const btns = [];
    const top = document.getElementById('submit-order-top'); if(top) btns.push(top);
    const bottom = document.getElementById('submit-order-bottom'); if(bottom) btns.push(bottom);
    // also include any default submit inputs
    document.querySelectorAll('input[type="submit"].btn.btn-primary').forEach(b => { if(!btns.includes(b)) btns.push(b); });
    btns.forEach(b => b.disabled = !ok);
  }

  // --- Add-item / NET(g) helpers ---
  function rowNetValid(r){
    const netEl = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
    const qtyEl = r.querySelector('.qty');
    const net = netEl ? parseFloat(netEl.value || 0) : 0;
    const qty = qtyEl ? parseInt(qtyEl.value || 1) : 1;
    if(!net || net <= 0 || isNaN(net)) return false;
    const sel = r.querySelector('.item-select');
    const idVal = sel ? sel.value : (r.querySelector('input.item-id-hidden') ? r.querySelector('input.item-id-hidden').value : null);
    if(!idVal) return false;
    const it = items.find(x => String(x.id) == String(idVal));
    if(it && it.purity_total_weight != null){
      // cumulative across rows for this item must not exceed purity total
      const cum = getCumulativeNetForItem(String(idVal));
      if((cum) > parseFloat(it.purity_total_weight)) return false;
      // also ensure this row's contribution is positive
      if((net * qty) > parseFloat(it.purity_total_weight)) return false;
    }
    return true;
  }

  function anyRowNetTooLarge(){
    const rows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
    for(const r of rows){
      const netEl = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
      const qtyEl = r.querySelector('.qty');
      const net = netEl ? parseFloat(netEl.value || 0) : 0;
      const qty = qtyEl ? parseInt(qtyEl.value || 1) : 1;
      if(!net || net <= 0 || isNaN(net)) continue; // empty rows ignored for this check
      const sel = r.querySelector('.item-select');
      const idVal = sel ? sel.value : (r.querySelector('input.item-id-hidden') ? r.querySelector('input.item-id-hidden').value : null);
      if(!idVal) continue;
      const it = items.find(x => String(x.id) == String(idVal));
      if(it && it.purity_total_weight != null){
        const cum = getCumulativeNetForItem(String(idVal));
        if(cum > parseFloat(it.purity_total_weight)) return true;
      }
    }
    return false;
  }

  // sum net * qty across all rows for a given item id
  function getCumulativeNetForItem(itemId){
    let sum = 0;
    const rows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
    for(const r of rows){
      // determine the item id for this row (select or hidden id)
      let idVal = null;
      const sel = r.querySelector('.item-select');
      if(sel && sel.value) idVal = String(sel.value);
      const hid = r.querySelector('input.item-id-hidden');
      if(!idVal && hid && hid.value) idVal = String(hid.value);
      if(!idVal) continue;
      if(String(idVal) !== String(itemId)) continue;
      // robustly find net and qty inputs
      let netEl = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
      if(!netEl) netEl = r.querySelector('.net-weight');
      let qtyEl = r.querySelector('.qty');
      if(!qtyEl) qtyEl = r.querySelector('input[name^="line_items"][name$="[quantity]"]');
      const net = netEl ? parseFloat((netEl.value || '').toString().replace(/,/g,'')) : 0;
      const qty = qtyEl ? parseInt((qtyEl.value || '1').toString().replace(/,/g,'')) : 1;
      if(net && !isNaN(net) && qty && !isNaN(qty)) sum += (net * qty);
      try{ console.debug('cumRow', {rowIndex: rows.indexOf(r), idVal: idVal, net: net, qty: qty, partial: (net*qty)}); }catch(e){}
    }
    try{ console.debug('cumSum', {itemId: itemId, sum: sum}); }catch(e){}
    return sum;
  }

  function updateAddButtonState(){
    const addBtn = document.getElementById('add-order-row');
    if(!addBtn) return;
    // if any row exceeds available weight, disable Add
    if(anyRowNetTooLarge()){ addBtn.disabled = true; return; }
    // determine if there exists any unselected item with remaining purity weight > 0
    const selectedIds = getSelectedIds();
    let anyRemaining = false;
    items.forEach(it => {
      const id = String(it.id);
      const total = (it.purity_total_weight != null) ? parseFloat(it.purity_total_weight) : null;
      const cum = getCumulativeNetForItem(id);
      const remaining = (total != null) ? (total - cum) : null;
      if(remaining != null && remaining > 0){
        // if item not already selected, it's available to add
        if(!selectedIds.has(id)) anyRemaining = true;
      }
    });
    // require that all existing rows have NET > 0 before allowing Add
    const rows = tbody ? Array.from(tbody.querySelectorAll('tr')) : [];
    // if there are no rows yet, allow adding a row
    if(rows.length === 0){ addBtn.disabled = false; return; }
    const allNetPositive = rows.every(r => {
      const netEl = r.querySelector('input[name^="line_items"][name$="[net_weight]"]');
      return !!netEl && !!netEl.value && parseFloat(netEl.value || 0) > 0;
    });
    addBtn.disabled = !(anyRemaining && allNetPositive);
  }

  // wire customer-related events to keep submit state in sync
  (function(){
    const existingEl = document.getElementById('existing_customer_id');
    const toggleEl2 = document.getElementById('toggle-new-customer');
    if(existingEl) existingEl.addEventListener('change', function(){
      // if an existing customer is selected, hide/clear new-customer toggle
      if(existingEl.value){ if(toggleEl2) { toggleEl2.checked = false; const newCust2 = document.getElementById('new-customer-form'); if(newCust2) newCust2.style.display = 'none'; } }
      updateSubmitButtons();
    });
    if(toggleEl2) toggleEl2.addEventListener('change', function(){
      const newCust2 = document.getElementById('new-customer-form');
      if(toggleEl2.checked){ if(newCust2) newCust2.style.display = 'block'; if(existingEl){ existingEl.value = ''; existingEl.disabled = true; } }
      else { if(newCust2) newCust2.style.display = 'none'; if(existingEl) existingEl.disabled = false; }
      updateSubmitButtons();
    });
    // watch new-customer inputs
    ['customer[full_name]','customer[phone]'].forEach(name => {
      const el = document.querySelector(`[name="${name}"]`);
      if(el) el.addEventListener('input', updateSubmitButtons);
    });
    // sanitize phone input to digits only and limit to 10 chars
    const phoneElSan = document.querySelector('input[name="customer[phone]"]');
    if(phoneElSan){
      phoneElSan.addEventListener('input', function(e){
        const cleaned = (this.value || '').replace(/\D/g,'').slice(0,10);
        if(this.value !== cleaned) this.value = cleaned;
        updateSubmitButtons();
      });
    }
    // initial sync
    updateSubmitButtons();
  })();

  // expose some helpers for other scripts or debugging
  window._orders_helpers = window._orders_helpers || {};
  window._orders_helpers.recalc = recalc;
  window._orders_helpers.updateSubmitButtons = updateSubmitButtons;
  window._orders_helpers.validateForm = validateForm;
  window._orders_helpers.isFormValidQuiet = isFormValidQuiet;

  // shared NET tooltip element
  const netTooltip = (function(){
    const el = document.createElement('div');
    el.id = 'net-tooltip';
    el.style.position = 'absolute';
    el.style.background = '#111';
    el.style.color = '#fff';
    el.style.padding = '6px 8px';
    el.style.borderRadius = '6px';
    el.style.fontSize = '12px';
    el.style.pointerEvents = 'none';
    el.style.display = 'none';
    el.style.zIndex = 2000;
    document.body.appendChild(el);
    return el;
  })();

  function showNetTooltip(target){ if(!netTooltip) return; netTooltip.style.display = 'block'; positionNetTooltip(target); }
  function hideNetTooltip(){ if(!netTooltip) return; netTooltip.style.display = 'none'; }
  function positionNetTooltip(target){
    try{
      const r = target.getBoundingClientRect();
      netTooltip.style.top = (window.scrollY + r.top - 36) + 'px';
      netTooltip.style.left = (window.scrollX + r.left) + 'px';
    }catch(e){}
  }
  function updateNetTooltip(target){
    try{
      // ensure totals are up to date
      try{ recalc(); }catch(e){}
      const sel = target.closest('tr').querySelector('.item-select');
      const idVal = sel ? String(sel.value) : null;
      if(!idVal){ netTooltip.textContent = 'Select an item to see purity availability.'; positionNetTooltip(target); return; }
      const it = items.find(x => String(x.id) == String(idVal));
      if(!it || it.purity_total_weight == null){ netTooltip.textContent = 'No purity info available.'; positionNetTooltip(target); return; }
      const cum = getCumulativeNetForItem(idVal);
      const total = parseFloat(it.purity_total_weight);
      const remaining = Math.max(0, (total - cum)).toFixed(3);
      netTooltip.textContent = `Purity available: ${total}g — Selected: ${cum.toFixed(3)}g — Remaining: ${remaining}g`;
      positionNetTooltip(target);
    }catch(e){}
  }

})();</script>
